/* ??? */
* [ ] fazer o bind correto de variaveis do tipo string e array
* [ ] checar se a redeclaração de uma funcao nao conflita com a lista de parametros
* [ ] remove code ambiguity in llvm.c (there's a lot!)
* [X] criar llvm_printf (que se encarregará de chamar a funcao indent())
* [X] criar macro/funcao que encapsule a adição de comentários no arquivo .ll final
* [ ] fazer algo como: llvm_new_reg(ltype) em vez do macro podre
* [ ] implementar ponteiro?
* [ ] criar função separada para o funcbody lol
* [ ] criar função separada no parser.y que se encarregue de criar um NODE_BLOCK

/* 21/03 */
* [*] fazer o dump da string table
* [*] terminar as conversoes
* [*] terminar as operacoes binarias (<, >)
* [*] implementar printf
* [*] testar tudo
* [*] começar funcoes

/* 22/03 */
* [*] if/while
* [*] fazer dump das funcoes definidas pelo programador
* [*] fazer definição de multiplas funcoes
* [*] fazer chamada de funcoes
* [*] fazer frame/context manager (para recursividade, ainda não 100% funcional)

/* 23/03 */
* [*] recursão de funções implementada e testada
* [*] consertar inicialização de variaveis globais
* [ ] arrays
* [ ] implementar scanf


AVISOS
OBS1:
No IR do LLVM, não há necessidade de criar temporarios para armazenar
literais; é possível usa-los diretamente nas operações sem que estejam
armazenados na memoria (o que por sua vez é feito por meio da operação alloca).

No entanto, foi uma escolha minha carregar os literais também na memória. Isso
permitiu simplificar bruscamente o código, porque não é necessário descobrir
de alguma forma se o valor em questão está armazenado em registrador ou em
memória. Isso teve implicações visíveis ao implementar os nós da AST de
conversão e de IF/WHILE. Nesse sentido, o backend feito REQUER que qualquer
valor a ser usado seja carregado em um pointer criado pela operação 'alloca'.
Isso aumenta o número de temporários, mas traz simplificações para o código.
> errata: não sei se essa foi uma escolha boa pra ser sincero :'), mas de fato
> trouxe alguns beneficios enquanto eu escrevia as partes do backend que fiz
> referência no texto acima. O código talvez ficou mais complicado do que deveria!

OBS2:
não é necessário converter explicitamente um valor i32 para i1 antes de
executar um br, basta dizer que o valor em questão é i1


COMENTÁRIOS ALEATÓRIOS
O fato de eu ter pulado a etapa de escrita do interpretador fez com que muitos
bugs que antes teriam sido descobertos nessa etapa fossem descobertos na etapa
seguinte (do backend com LLVM). Isso fez com que eu tivesse de fazer mais
mudanças do que seriam necessárias no arquivo 'parser.y'. Isso foi
especialmente ruim porque dificultou a detecção de bugs na etapa do backend,
visto que não se sabia a princípio se o problema estaria na implementação do
código em si do backend ou se estaria no código do parser.y. Felizmente foi
possível chegar a causa raiz dos problemas por meio de uma depuração cautelosa
e demorada, que no fim das contas foi mais cansativa e tomou mais tempo do que
deveria, do que se o interpretador tivesse sido feito.
