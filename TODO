/* ??? */
* [ ] fazer o bind correto de variaveis do tipo string e array
* [ ] checar se a redeclaração de uma funcao nao conflita com a lista de parametros
* [ ] remove code ambiguity in llvm.c (there's a lot!)
* [ ] criar llvm_printf (que se encarregará de chamar a funcao indent())
* [ ] criar macro/funcao que encapsule a adição de comentários no arquivo .ll final
* [ ] fazer algo como: llvm_new_reg(ltype) em vez do macro podre
* [ ] implementar ponteiro?

/* 21/03 */
* [*] fazer o dump da string table
* [*] terminar as conversoes
* [*] terminar as operacoes binarias (<, >)
* [*] implementar printf
* [*] testar tudo
* [*] começar funcoes

/* 22/03 */
* [*] if/while
* [*] fazer dump das funcoes definidas pelo programador
* [*] fazer definição de multiplas funcoes
* [*] fazer chamada de funcoes
* [*] fazer frame/context manager (recursividade)

/* 23/03 */
* [ ] consertar inicialização de variaveis globais
* [ ] implementar scanf
* [ ] arrays


AVISOS
OBS1:
No IR do LLVM, não há necessidade de criar temporarios para armazenar
literais; é possível usa-los diretamente nas operações sem que estejam
armazenados na memoria (o que por sua vez é feito por meio da operação alloca).

No entanto, foi uma escolha minha carregar os literais também na memória. Isso
permitiu simplificar bruscamente o código, porque não é necessário descobrir
de alguma forma se o valor em questão está armazenado em registrador ou em
memória. Isso teve implicações visíveis ao implementar os nós da AST de
conversão e de IF/WHILE. Nesse sentido, o backend feito REQUER que qualquer
valor a ser usado seja carregado em um pointer criado pela operação 'alloca'.
Isso aumenta o número de temporários, mas traz simplificações para o código.

OBS2:
não é necessário converter explicitamente um valor i32 para i1 antes de
executar um br, basta dizer que o valor em questão é i1
